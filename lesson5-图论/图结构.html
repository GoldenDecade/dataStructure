<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
图结构-- 图论
一种分析问题的方法,把一些问题抽象为图
<script src="./dict.js"></script>
<script src="./queue.js"></script>
<script>
    // 图结构  --  图表
    // 引申: 矩阵 就是两个点之间的连线, 数值就是距离
    class Graph {
		constructor() {
			// 顶点集合
			this.vertexes = []
            // 路径字典
            this.edges = new Dictionary()
		}
		// 添加顶点
        addVertex(v) {
			this.vertexes.push(v)
	        this.edges.set(v, [])
        }
        // 添加边  从v1 定点 到 v2 定点
        // 有向边 && 无向边
        // 这里定为 无向边; 即从 v1 --> v2  && v2 --> v1
        addEdge(v1, v2) {
			if (this.edges.get(v1)) {
				this.edges.get(v1).push(v2)
			}
			if (this.edges.get(v2)) {
				this.edges.get(v2).push(v1)
            }
        }
        toString() {
			let str = ''
            for (let i = 0; i < this.vertexes.length; i++) {
			    const vertex = this.vertexes[i]
                const edges = this.edges.get(vertex)
	            console.log(edges);
	            str += vertex + ' : '
	            for (let j = 0; j < edges.length; j++) {
					str += edges[j] + ' '
                }
				str += '\n'
            }
			return str
        }
		// 遍历之前 对每个顶点设置三种状态  white gray black
        // 初始时, 全部设置为 white
		initializeColor() {
			let colors = {}
            for (let i = 0; i < this.vertexes.length; i++) {
				colors[this.vertexes[i]] = 'white'
            }
			return colors
        }
		// 广度遍历
        // v: 起始点
        // handler: 对遍历点的处理函数
        bfs(v, handler) {
			// 一层一层的进行遍历
            // 先初始化颜色
            let colors = this.initializeColor()
            let queue = new Queue()
            queue.enqueue(v)
            while(!queue.isEmpty()) {
				const v = queue.dequeue()
				const edges = this.edges.get(v)
                for (let i = 0; i < edges.length; i++) {
					let linkVertex = edges[i]
                    if(colors[linkVertex] === 'white') {
	                    queue.enqueue(linkVertex)
	                    colors[linkVertex] = 'gray'
                    }
                }
                colors[v]= 'black'
                if (handler) {
	                handler(v)
                }
            }
        }

        // 深度遍历--递归调用
        dfs(v, handler) {
	        // 先初始化颜色
	        let colors = this.initializeColor()
	        this.dfsHandler(v, colors, handler)
        }
		dfsHandler(v, colors, handler) {
            colors[v] = 'gray'
			const edges = this.edges.get(v)
			for (let i = 0; i < edges.length; i++) {
				let linkVertex = edges[i]
	            if (colors[linkVertex] === 'white') {
		            this.dfsHandler(linkVertex, colors, handler)
	            }else {
					continue
                }
            }
			if (handler) {
				handler(v)
			}
			colors[v] = 'black'
        }
    }
    // 测试代码
    var graph = new Graph()

    // 添加顶点
    var myVertexes = ["A", "B", "C", "D", "E", "F", "G", "H", "I"]
    for (var i = 0; i < myVertexes.length; i++) {
	    graph.addVertex(myVertexes[i])
    }

    // 添加边
    graph.addEdge('A', 'B');
    graph.addEdge('A', 'C');
    graph.addEdge('A', 'D');
    graph.addEdge('C', 'D');
    graph.addEdge('C', 'G');
    graph.addEdge('D', 'G');
    graph.addEdge('D', 'H');
    graph.addEdge('B', 'E');
    graph.addEdge('B', 'F');
    graph.addEdge('E', 'I');
    console.log(graph.toString());

    // 调用广度优先算法
    // var result = ""
    // graph.bfs(graph.vertexes[0], function (v) {
	//     result += v + " "
    // })
    // console.log(result);
    graph.dfs(graph.vertexes[0], function (v){
	    console.log(v);
    })
</script>
</body>
</html>
